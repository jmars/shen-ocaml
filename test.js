// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var Obj = require("bs-platform/lib/js/obj.js");
var Char = require("bs-platform/lib/js/char.js");
var List = require("bs-platform/lib/js/list.js");
var Unix = require("bs-platform/lib/js/unix.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function is_float(v) {
  try {
    Caml_format.caml_float_of_string(v);
    return true;
  }
  catch (exn){
    return false;
  }
}

var i = /* record */[/* contents */0];

function gensym(param) {
  var r = "x" + String(i[0]);
  i[0] = i[0] + 1 | 0;
  return r;
}

function sexp_to_kl(_sexp) {
  while(true) {
    var sexp = _sexp;
    if (sexp[0] >= 848054398) {
      var match = sexp[1];
      if (match) {
        var r = match[0];
        var exit = 0;
        if (typeof r === "number" || r[0] !== 726615281) {
          exit = 1;
        } else {
          switch (r[1]) {
            case "and" : 
                var match$1 = match[1];
                if (match$1) {
                  var match$2 = match$1[1];
                  if (match$2 && !match$2[1]) {
                    return /* If */Block.__(8, [
                              sexp_to_kl(match$1[0]),
                              sexp_to_kl(match$2[0]),
                              /* Boolean */Block.__(0, [false])
                            ]);
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                break;
            case "cond" : 
                var match$3 = match[1];
                if (match$3) {
                  var match$4 = match$3[0];
                  if (typeof match$4 === "number" || match$4[0] !== 848054398) {
                    exit = 1;
                  } else {
                    var match$5 = match$4[1];
                    if (match$5) {
                      var match$6 = match$5[1];
                      if (match$6 && !match$6[1]) {
                        _sexp = /* `List */[
                          848054398,
                          /* :: */[
                            /* `Atom */[
                              726615281,
                              "if"
                            ],
                            /* :: */[
                              match$5[0],
                              /* :: */[
                                match$6[0],
                                /* :: */[
                                  /* `List */[
                                    848054398,
                                    /* :: */[
                                      /* `Atom */[
                                        726615281,
                                        "cond"
                                      ],
                                      match$3[1]
                                    ]
                                  ],
                                  /* [] */0
                                ]
                              ]
                            ]
                          ]
                        ];
                        continue ;
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                  }
                } else {
                  return /* App */Block.__(4, [
                            /* Symbol */Block.__(2, ["simple-error"]),
                            /* String */Block.__(3, ["case failure"])
                          ]);
                }
                break;
            case "do" : 
                var match$7 = match[1];
                if (match$7) {
                  var z = match$7[1];
                  var x = match$7[0];
                  if (z) {
                    return /* Let */Block.__(6, [
                              gensym(/* () */0),
                              sexp_to_kl(x),
                              sexp_to_kl(/* `List */[
                                    848054398,
                                    /* :: */[
                                      /* `Atom */[
                                        726615281,
                                        "do"
                                      ],
                                      z
                                    ]
                                  ])
                            ]);
                  } else {
                    _sexp = x;
                    continue ;
                  }
                } else {
                  exit = 1;
                }
                break;
            case "freeze" : 
                var match$8 = match[1];
                if (match$8 && !match$8[1]) {
                  return /* Lambda */Block.__(5, [
                            gensym(/* () */0),
                            sexp_to_kl(match$8[0])
                          ]);
                } else {
                  exit = 1;
                }
                break;
            case "if" : 
                var match$9 = match[1];
                if (match$9) {
                  var match$10 = match$9[1];
                  if (match$10) {
                    var match$11 = match$10[1];
                    if (match$11 && !match$11[1]) {
                      return /* If */Block.__(8, [
                                sexp_to_kl(match$9[0]),
                                sexp_to_kl(match$10[0]),
                                sexp_to_kl(match$11[0])
                              ]);
                    } else {
                      exit = 1;
                    }
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                break;
            case "lambda" : 
                var match$12 = match[1];
                if (match$12) {
                  var match$13 = match$12[0];
                  if (typeof match$13 === "number" || match$13[0] !== 726615281) {
                    exit = 1;
                  } else {
                    var match$14 = match$12[1];
                    if (match$14 && !match$14[1]) {
                      return /* Lambda */Block.__(5, [
                                match$13[1],
                                sexp_to_kl(match$14[0])
                              ]);
                    } else {
                      exit = 1;
                    }
                  }
                } else {
                  exit = 1;
                }
                break;
            case "let" : 
                var match$15 = match[1];
                if (match$15) {
                  var match$16 = match$15[0];
                  if (typeof match$16 === "number" || match$16[0] !== 726615281) {
                    exit = 1;
                  } else {
                    var match$17 = match$15[1];
                    if (match$17) {
                      var match$18 = match$17[1];
                      if (match$18 && !match$18[1]) {
                        return /* Let */Block.__(6, [
                                  match$16[1],
                                  sexp_to_kl(match$17[0]),
                                  sexp_to_kl(match$18[0])
                                ]);
                      } else {
                        exit = 1;
                      }
                    } else {
                      exit = 1;
                    }
                  }
                } else {
                  exit = 1;
                }
                break;
            case "or" : 
                var match$19 = match[1];
                if (match$19) {
                  var match$20 = match$19[1];
                  if (match$20 && !match$20[1]) {
                    return /* If */Block.__(8, [
                              sexp_to_kl(match$19[0]),
                              /* Boolean */Block.__(0, [true]),
                              sexp_to_kl(match$20[0])
                            ]);
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                break;
            case "str" : 
                var match$21 = match[1];
                if (match$21) {
                  var match$22 = match$21[0];
                  if (typeof match$22 === "number" || match$22[0] !== 726615281 || match$21[1]) {
                    exit = 1;
                  } else {
                    return /* String */Block.__(3, [match$22[1]]);
                  }
                } else {
                  exit = 1;
                }
                break;
            case "thaw" : 
                var match$23 = match[1];
                if (match$23 && !match$23[1]) {
                  return /* App */Block.__(4, [
                            /* Symbol */Block.__(2, ["thaw"]),
                            sexp_to_kl(match$23[0])
                          ]);
                } else {
                  exit = 1;
                }
                break;
            case "trap-error" : 
                var match$24 = match[1];
                if (match$24) {
                  var match$25 = match$24[1];
                  if (match$25 && !match$25[1]) {
                    return /* Trap */Block.__(7, [
                              sexp_to_kl(match$24[0]),
                              sexp_to_kl(match$25[0])
                            ]);
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
                break;
            default:
              exit = 1;
          }
        }
        if (exit === 1) {
          var match$26 = match[1];
          if (match$26) {
            var match$27 = match$26[1];
            var x$1 = match$26[0];
            if (match$27) {
              _sexp = /* `List */[
                848054398,
                /* :: */[
                  /* `List */[
                    848054398,
                    /* :: */[
                      r,
                      /* :: */[
                        x$1,
                        /* [] */0
                      ]
                    ]
                  ],
                  /* :: */[
                    match$27[0],
                    match$27[1]
                  ]
                ]
              ];
              continue ;
            } else {
              return /* App */Block.__(4, [
                        sexp_to_kl(r),
                        sexp_to_kl(x$1)
                      ]);
            }
          } else {
            return /* App */Block.__(4, [
                      sexp_to_kl(r),
                      /* Number */Block.__(1, [0.0])
                    ]);
          }
        }
        
      } else {
        return /* Empty */0;
      }
    } else {
      var v = sexp[1];
      switch (v) {
        case "false" : 
            return /* Boolean */Block.__(0, [false]);
        case "true" : 
            return /* Boolean */Block.__(0, [true]);
        default:
          if (is_float(v)) {
            return /* Number */Block.__(1, [Caml_format.caml_float_of_string(v)]);
          } else {
            return /* Symbol */Block.__(2, [v]);
          }
      }
    }
  };
}

function extract_symbol(s) {
  if (typeof s === "number") {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "test.ml",
            57,
            62
          ]
        ];
  }
  if (s[0] !== 726615281) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "test.ml",
            57,
            62
          ]
        ];
  }
  return s[1];
}

function toplevel_to_kl(sexp) {
  if (typeof sexp === "number" || sexp[0] !== 848054398) {
    return /* Expr */Block.__(1, [sexp_to_kl(sexp)]);
  } else {
    var match = sexp[1];
    if (match) {
      var match$1 = match[0];
      if (typeof match$1 === "number" || match$1[0] !== 726615281 || match$1[1] !== "defun") {
        return /* Expr */Block.__(1, [sexp_to_kl(sexp)]);
      } else {
        var match$2 = match[1];
        if (match$2) {
          var match$3 = match$2[0];
          if (typeof match$3 === "number" || match$3[0] !== 726615281) {
            return /* Expr */Block.__(1, [sexp_to_kl(sexp)]);
          } else {
            var match$4 = match$2[1];
            if (match$4) {
              var match$5 = match$4[0];
              if (typeof match$5 === "number" || match$5[0] !== 848054398) {
                return /* Expr */Block.__(1, [sexp_to_kl(sexp)]);
              } else {
                var match$6 = match$4[1];
                if (match$6 && !match$6[1]) {
                  return /* Defun */Block.__(0, [
                            match$3[1],
                            List.map(extract_symbol, match$5[1]),
                            sexp_to_kl(match$6[0])
                          ]);
                } else {
                  return /* Expr */Block.__(1, [sexp_to_kl(sexp)]);
                }
              }
            } else {
              return /* Expr */Block.__(1, [sexp_to_kl(sexp)]);
            }
          }
        } else {
          return /* Expr */Block.__(1, [sexp_to_kl(sexp)]);
        }
      }
    } else {
      return /* Expr */Block.__(1, [sexp_to_kl(sexp)]);
    }
  }
}

function file_to_kl(sexps) {
  return List.map(toplevel_to_kl, sexps);
}

var Parser$prime1 = /* module */[
  /* is_float */is_float,
  /* i */i,
  /* gensym */gensym,
  /* sexp_to_kl */sexp_to_kl,
  /* extract_symbol */extract_symbol,
  /* toplevel_to_kl */toplevel_to_kl,
  /* file_to_kl */file_to_kl
];

var Exn = Caml_exceptions.create("Test.Shen'1.Exn");

var functions = Hashtbl.create(undefined, 255);

var globals = Hashtbl.create(undefined, 255);

function assert_function(x) {
  if ((x.tag | 0) === Obj.closure_tag) {
    return x;
  } else {
    throw [
          Exn,
          "Invalid function application"
        ];
  }
}

function define(n, f) {
  return Hashtbl.add(functions, n, f);
}

function assert_bool(s) {
  if (s.tag === 2) {
    return s[0];
  } else {
    throw [
          Exn,
          "Expected a bool"
        ];
  }
}

function thaw(a) {
  if ((a.tag | 0) === Obj.closure_tag) {
    return Curry._1(a, /* () */0);
  } else {
    throw [
          Exn,
          "Attempt to thaw non-frozen"
        ];
  }
}

function simple_error(a) {
  if (a.tag === 1) {
    throw [
          Exn,
          a[0]
        ];
  } else {
    throw [
          Exn,
          "simple-error: argument must be a string"
        ];
  }
}

function error_to_string(a) {
  if (a.tag === 4) {
    var match = a[0];
    if (match[0] === Exn) {
      return /* String */Block.__(1, [match[1]]);
    } else {
      throw [
            Exn,
            "error-to-string: argument must be an error"
          ];
    }
  } else {
    throw [
          Exn,
          "error-to-string: argument must be an error"
        ];
  }
}

function intern(a) {
  if (a.tag === 1) {
    var s = a[0];
    switch (s) {
      case "false" : 
          return /* Boolean */Block.__(2, [false]);
      case "true" : 
          return /* Boolean */Block.__(2, [true]);
      default:
        return /* Symbol */Block.__(0, [s]);
    }
  } else {
    throw [
          Exn,
          "intern: first argument must be a string"
        ];
  }
}

function set(name, value) {
  if (name.tag) {
    throw [
          Exn,
          "set: first argument must be a symbol"
        ];
  } else {
    Hashtbl.add(globals, name[0], value);
    return value;
  }
}

function value(name) {
  if (name.tag) {
    throw [
          Exn,
          "value: first argument must be a symbol"
        ];
  } else {
    try {
      return Hashtbl.find(globals, name[0]);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Exn,
              "value: no value"
            ];
      }
      throw exn;
    }
  }
}

function is_number(n) {
  if (n.tag === 3) {
    return /* Boolean */Block.__(2, [true]);
  } else {
    return /* Boolean */Block.__(2, [false]);
  }
}

function add(a, b) {
  if (a.tag === 3) {
    if (b.tag === 3) {
      return /* Number */Block.__(3, [a[0] + b[0]]);
    } else {
      throw [
            Exn,
            "+: both arguments must be numbers"
          ];
    }
  } else {
    throw [
          Exn,
          "+: both arguments must be numbers"
        ];
  }
}

function sub(a, b) {
  if (a.tag === 3) {
    if (b.tag === 3) {
      return /* Number */Block.__(3, [a[0] - b[0]]);
    } else {
      throw [
            Exn,
            "-: both arguments must be numbers"
          ];
    }
  } else {
    throw [
          Exn,
          "-: both arguments must be numbers"
        ];
  }
}

function mul(a, b) {
  if (a.tag === 3) {
    if (b.tag === 3) {
      return /* Number */Block.__(3, [a[0] * b[0]]);
    } else {
      throw [
            Exn,
            "*: both arguments must be numbers"
          ];
    }
  } else {
    throw [
          Exn,
          "*: both arguments must be numbers"
        ];
  }
}

function div(a, b) {
  if (a.tag === 3) {
    if (b.tag === 3) {
      return /* Number */Block.__(3, [a[0] / b[0]]);
    } else {
      throw [
            Exn,
            "/: both arguments must be numbers"
          ];
    }
  } else {
    throw [
          Exn,
          "/: both arguments must be numbers"
        ];
  }
}

function gt(a, b) {
  if (a.tag === 3) {
    if (b.tag === 3) {
      return /* Boolean */Block.__(2, [a[0] > b[0]]);
    } else {
      throw [
            Exn,
            ">: both arguments must be numbers"
          ];
    }
  } else {
    throw [
          Exn,
          ">: both arguments must be numbers"
        ];
  }
}

function lt(a, b) {
  if (a.tag === 3) {
    if (b.tag === 3) {
      return /* Boolean */Block.__(2, [a[0] < b[0]]);
    } else {
      throw [
            Exn,
            "<: both arguments must be numbers"
          ];
    }
  } else {
    throw [
          Exn,
          "<: both arguments must be numbers"
        ];
  }
}

function gte(a, b) {
  if (a.tag === 3) {
    if (b.tag === 3) {
      return /* Boolean */Block.__(2, [a[0] >= b[0]]);
    } else {
      throw [
            Exn,
            ">=: both arguments must be numbers"
          ];
    }
  } else {
    throw [
          Exn,
          ">=: both arguments must be numbers"
        ];
  }
}

function lte(a, b) {
  if (a.tag === 3) {
    if (b.tag === 3) {
      return /* Boolean */Block.__(2, [a[0] <= b[0]]);
    } else {
      throw [
            Exn,
            "<=: both arguments must be numbers"
          ];
    }
  } else {
    throw [
          Exn,
          "<=: both arguments must be numbers"
        ];
  }
}

function is_string(a) {
  if (a.tag === 1) {
    return /* Boolean */Block.__(2, [true]);
  } else {
    return /* Boolean */Block.__(2, [false]);
  }
}

function pos(str, i) {
  if (str.tag === 1) {
    if (i.tag === 3) {
      var i$1 = i[0];
      try {
        return /* String */Block.__(1, [$$String.sub(str[0], i$1 | 0, (i$1 | 0) + 1 | 0)]);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
          throw [
                Exn,
                "pos: invalid index"
              ];
        }
        throw exn;
      }
    } else {
      throw [
            Exn,
            "pos: args must be string -> number"
          ];
    }
  } else {
    throw [
          Exn,
          "pos: args must be string -> number"
        ];
  }
}

function tlstr(str) {
  if (str.tag === 1) {
    var str$1 = str[0];
    if (str$1 === "") {
      throw [
            Exn,
            "tlstr on empty string"
          ];
    } else {
      return /* String */Block.__(1, [$$String.sub(str$1, 1, str$1.length - 1 | 0)]);
    }
  } else {
    throw [
          Exn,
          "tlstr: argument must be a string"
        ];
  }
}

function cn(a, b) {
  if (a.tag === 1) {
    if (b.tag === 1) {
      return /* String */Block.__(1, [a[0] + b[0]]);
    } else {
      throw [
            Exn,
            "cn: both arguments must be strings"
          ];
    }
  } else {
    throw [
          Exn,
          "cn: both arguments must be strings"
        ];
  }
}

function str(a) {
  switch (a.tag | 0) {
    case 0 : 
        return /* String */Block.__(1, [a[0]]);
    case 1 : 
        return a;
    case 2 : 
        if (a[0]) {
          return /* String */Block.__(1, ["true"]);
        } else {
          return /* String */Block.__(1, ["false"]);
        }
    case 3 : 
        return /* String */Block.__(1, [Pervasives.string_of_float(a[0])]);
    case 4 : 
        var match = a[0];
        if (match[0] === Exn) {
          return /* String */Block.__(1, [match[1]]);
        } else {
          throw [
                Exn,
                "str: invalid argument"
              ];
        }
    case 5 : 
        return /* String */Block.__(1, ["<vector " + (String(a[0].length) + ">")]);
    case 6 : 
        var match$1 = a[0];
        if (match$1) {
          var match$2 = str(match$1[0]);
          var match$3 = str(/* List */Block.__(6, [match$1[1]]));
          if (match$2.tag === 1) {
            if (match$3.tag === 1) {
              return /* String */Block.__(1, ["[cons " + (match$2[0] + (" " + (match$3[0] + "]")))]);
            } else {
              throw [
                    Exn,
                    "str: invalid argument"
                  ];
            }
          } else {
            throw [
                  Exn,
                  "str: invalid argument"
                ];
          }
        } else {
          return /* String */Block.__(1, ["[]"]);
        }
    case 7 : 
        return /* String */Block.__(1, ["stream"]);
    
  }
}

function string_to_n(str) {
  if (str.tag === 1) {
    try {
      return /* Number */Block.__(3, [Caml_string.get(str[0], 0)]);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
        throw [
              Exn,
              "string->n: empty string"
            ];
      }
      throw exn;
    }
  } else {
    throw [
          Exn,
          "string->n: arg must be a string"
        ];
  }
}

function n_to_string(num) {
  if (num.tag === 3) {
    return /* String */Block.__(1, [$$String.make(1, Char.chr(num[0] | 0))]);
  } else {
    throw [
          Exn,
          "n->string: arg must be a number"
        ];
  }
}

function absvector(num) {
  if (num.tag === 3) {
    return /* Vector */Block.__(5, [Caml_array.caml_make_vect(num[0] | 0, /* Symbol */Block.__(0, ["nil"]))]);
  } else {
    throw [
          Exn,
          "absvector: arg must be a number"
        ];
  }
}

function is_cons(v) {
  if (v.tag === 6) {
    return /* Boolean */Block.__(2, [true]);
  } else {
    return /* Boolean */Block.__(2, [false]);
  }
}

function cons(v, l) {
  if (l.tag === 6) {
    return /* List */Block.__(6, [/* :: */[
                v,
                l[0]
              ]]);
  } else {
    throw [
          Exn,
          "cons: second arg must be a list"
        ];
  }
}

function hd(l) {
  if (l.tag === 6) {
    var match = l[0];
    if (match) {
      return match[0];
    } else {
      throw [
            Exn,
            "hd: empty list"
          ];
    }
  } else {
    throw [
          Exn,
          "hd: arg must be a list"
        ];
  }
}

function tl(l) {
  if (l.tag === 6) {
    var match = l[0];
    if (match) {
      return /* List */Block.__(6, [match[1]]);
    } else {
      throw [
            Exn,
            "tl: empty list"
          ];
    }
  } else {
    throw [
          Exn,
          "tl: arg must be a list"
        ];
  }
}

function write_byte($$byte, stream) {
  if ($$byte.tag === 3) {
    if (stream.tag === 7) {
      var $$byte$1 = $$byte[0];
      Pervasives.output_byte(stream[1], $$byte$1 | 0);
      return /* Number */Block.__(3, [$$byte$1]);
    } else {
      throw [
            Exn,
            "write-byte: args must be number -> stream"
          ];
    }
  } else {
    throw [
          Exn,
          "write-byte: args must be number -> stream"
        ];
  }
}

function read_byte(stream) {
  if (stream.tag === 7) {
    return /* Number */Block.__(3, [Pervasives.input_byte(stream[0])]);
  } else {
    throw [
          Exn,
          "read-byte: arg must be a string"
        ];
  }
}

function open_stream(path, config) {
  if (path.tag === 1) {
    if (config.tag) {
      throw [
            Exn,
            "open: args must be string -> symbol"
          ];
    } else {
      var path$1 = path[0];
      return /* Stream */Block.__(7, [
                Pervasives.open_in_bin(path$1),
                Pervasives.open_out_bin(path$1)
              ]);
    }
  } else {
    throw [
          Exn,
          "open: args must be string -> symbol"
        ];
  }
}

function close_stream(stream) {
  if (stream.tag === 7) {
    Pervasives.close_in(stream[0]);
    Pervasives.close_out(stream[1]);
    return /* List */Block.__(6, [/* [] */0]);
  } else {
    throw [
          Exn,
          "close: arg must be a stream"
        ];
  }
}

function eq(a, b) {
  return /* Boolean */Block.__(2, [Caml_obj.caml_equal(a, b)]);
}

var start_time = Unix.time(/* () */0);

function get_time(a) {
  if (a.tag) {
    throw [
          Exn,
          "get-time: invalid arg"
        ];
  } else if (a[0] === "unix") {
    return /* Number */Block.__(3, [Unix.time(/* () */0)]);
  } else {
    return /* Number */Block.__(3, [Unix.time(/* () */0) - start_time]);
  }
}

function is_boolean(a) {
  if (a.tag === 2) {
    return /* Boolean */Block.__(2, [true]);
  } else {
    return /* Boolean */Block.__(2, [false]);
  }
}

function is_symbol(a) {
  if (true && (a.tag | 0) === Obj.closure_tag || a.tag) {
    return /* Boolean */Block.__(2, [false]);
  } else {
    return /* Boolean */Block.__(2, [true]);
  }
}

function value_to_sexp(v) {
  switch (v.tag | 0) {
    case 0 : 
        return /* `Atom */[
                726615281,
                v[0]
              ];
    case 1 : 
        return /* `List */[
                848054398,
                /* :: */[
                  /* `Atom */[
                    726615281,
                    "str"
                  ],
                  /* :: */[
                    /* `Atom */[
                      726615281,
                      v[0]
                    ],
                    /* [] */0
                  ]
                ]
              ];
    case 2 : 
        return /* `Atom */[
                726615281,
                Pervasives.string_of_bool(v[0])
              ];
    case 3 : 
        return /* `Atom */[
                726615281,
                Pervasives.string_of_float(v[0])
              ];
    case 6 : 
        return /* `List */[
                848054398,
                List.map(value_to_sexp, v[0])
              ];
    default:
      throw [
            Exn,
            "Invalid value in eval"
          ];
  }
}

var EvalEnv = $$Map.Make([$$String.compare]);

function $$eval(_env, _e) {
  while(true) {
    var e = _e;
    var env = _env;
    if (typeof e === "number") {
      throw [
            Exn,
            "eval error"
          ];
    } else {
      switch (e.tag | 0) {
        case 0 : 
            return /* Boolean */Block.__(2, [e[0]]);
        case 1 : 
            return /* Number */Block.__(3, [e[0]]);
        case 2 : 
            var s = e[0];
            if (Curry._2(EvalEnv[/* mem */2], s, env)) {
              return Curry._2(EvalEnv[/* find */21], s, env);
            } else {
              return /* Symbol */Block.__(0, [s]);
            }
        case 3 : 
            return /* String */Block.__(1, [e[0]]);
        case 4 : 
            var f = e[0];
            var exit = 0;
            if (typeof f === "number" || f.tag !== 2) {
              exit = 1;
            } else {
              var f$1 = Hashtbl.find(functions, f[0]);
              return Curry._1(f$1, $$eval(env, e[1]));
            }
            if (exit === 1) {
              var f$2 = $$eval(env, f);
              return Curry._1(f$2, $$eval(env, e[1]));
            }
            break;
        case 5 : 
            var b = e[1];
            var a = e[0];
            return (function(env,a,b){
            return function (av) {
              var benv = Curry._3(EvalEnv[/* add */3], a, av, env);
              return $$eval(benv, b);
            }
            }(env,a,b));
        case 6 : 
            var benv = Curry._3(EvalEnv[/* add */3], e[0], $$eval(env, e[1]), env);
            _e = e[2];
            _env = benv;
            continue ;
        case 7 : 
            try {
              return $$eval(env, e[0]);
            }
            catch (raw_e){
              var e$1 = Caml_js_exceptions.internalToOCamlException(raw_e);
              if (e$1[0] === Exn) {
                var h = $$eval(env, e[1]);
                return Curry._1(h, /* Error */Block.__(4, [e$1]));
              } else {
                throw e$1;
              }
            }
        case 8 : 
            var match = $$eval(env, e[0]);
            if (match.tag === 2) {
              if (match[0]) {
                _e = e[1];
                continue ;
              } else {
                _e = e[2];
                continue ;
              }
            } else {
              throw [
                    Exn,
                    "Invalid if condition - must be a boolean"
                  ];
            }
        
      }
    }
  };
}

function eval_kl(e) {
  if (e.tag === 6) {
    var sexp = value_to_sexp(e);
    var ast = sexp_to_kl(sexp);
    return $$eval(EvalEnv[/* empty */0], ast);
  } else {
    throw [
          Exn,
          "eval-kl: invalid expression"
        ];
  }
}

Hashtbl.add(functions, "thaw", thaw);

Hashtbl.add(functions, "simple-error", simple_error);

Hashtbl.add(functions, "error-to-string", error_to_string);

Hashtbl.add(functions, "simple-error", simple_error);

Hashtbl.add(functions, "intern", intern);

Hashtbl.add(functions, "set", set);

Hashtbl.add(functions, "value", value);

Hashtbl.add(functions, "number?", is_number);

Hashtbl.add(functions, "+", add);

Hashtbl.add(functions, "-", sub);

Hashtbl.add(functions, "*", mul);

Hashtbl.add(functions, "/", div);

Hashtbl.add(functions, ">", gt);

Hashtbl.add(functions, "<", lt);

Hashtbl.add(functions, "<=", gte);

Hashtbl.add(functions, ">=", lte);

Hashtbl.add(functions, "string?", is_string);

Hashtbl.add(functions, "pos", pos);

Hashtbl.add(functions, "tlstr", tlstr);

Hashtbl.add(functions, "cn", cn);

Hashtbl.add(functions, "str", str);

Hashtbl.add(functions, "string->n", string_to_n);

Hashtbl.add(functions, "n<-string", n_to_string);

Hashtbl.add(functions, "absvector", absvector);

Hashtbl.add(functions, "cons?", is_cons);

Hashtbl.add(functions, "hd", hd);

Hashtbl.add(functions, "tl", tl);

Hashtbl.add(functions, "write-byte", write_byte);

Hashtbl.add(functions, "read-byte", read_byte);

Hashtbl.add(functions, "open", open_stream);

Hashtbl.add(functions, "close", close_stream);

Hashtbl.add(functions, "=", eq);

Hashtbl.add(functions, "get-time", get_time);

Hashtbl.add(functions, "boolean?", is_boolean);

Hashtbl.add(functions, "symbol?", is_symbol);

var Shen$prime1 = /* module */[
  /* is_bucklescript */false,
  /* Exn */Exn,
  /* functions */functions,
  /* globals */globals,
  /* assert_function */assert_function,
  /* define */define,
  /* assert_bool */assert_bool,
  /* thaw */thaw,
  /* simple_error */simple_error,
  /* error_to_string */error_to_string,
  /* intern */intern,
  /* set */set,
  /* value */value,
  /* is_number */is_number,
  /* add */add,
  /* sub */sub,
  /* mul */mul,
  /* div */div,
  /* gt */gt,
  /* lt */lt,
  /* gte */gte,
  /* lte */lte,
  /* is_string */is_string,
  /* pos */pos,
  /* tlstr */tlstr,
  /* cn */cn,
  /* str */str,
  /* string_to_n */string_to_n,
  /* n_to_string */n_to_string,
  /* absvector */absvector,
  /* is_cons */is_cons,
  /* cons */cons,
  /* hd */hd,
  /* tl */tl,
  /* write_byte */write_byte,
  /* read_byte */read_byte,
  /* open_stream */open_stream,
  /* close_stream */close_stream,
  /* eq */eq,
  /* start_time */start_time,
  /* get_time */get_time,
  /* is_boolean */is_boolean,
  /* is_symbol */is_symbol,
  /* value_to_sexp */value_to_sexp,
  /* EvalEnv */EvalEnv,
  /* eval */$$eval,
  /* eval_kl */eval_kl
];

function f(x) {
  return /* Symbol */Block.__(0, ["loop"]);
}

Hashtbl.add(functions, "shen.loop", f);

function f$1(x) {
  return /* Symbol */Block.__(0, ["credits"]);
}

Hashtbl.add(functions, "shen.credits", f$1);

function f$2(x, x$1, x$2) {
  return /* Symbol */Block.__(0, ["foo"]);
}

Hashtbl.add(functions, "shen.repl", f$2);

exports.Parser$prime1 = Parser$prime1;
exports.Shen$prime1 = Shen$prime1;
/* functions Not a pure module */
