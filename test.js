// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var Exn = Caml_exceptions.create("Test.Shen'1.Exn");

var functions = Hashtbl.create(undefined, 255);

var globals = Hashtbl.create(undefined, 255);

function assert_function(f) {
  if (f.tag === 7) {
    return f[0];
  } else {
    throw [
          Exn,
          "Invalid function application"
        ];
  }
}

function check_symbol(s) {
  if (Hashtbl.mem(functions, s)) {
    return Hashtbl.find(functions, s);
  } else {
    return /* Symbol */Block.__(0, [s]);
  }
}

function assert_bool(s) {
  if (s.tag === 2) {
    return s[0];
  } else {
    throw [
          Exn,
          "Expected a bool"
        ];
  }
}

function kl_if(c) {
  return /* Lambda */Block.__(7, [(function (it) {
                return /* Lambda */Block.__(7, [(function (iff) {
                              if (assert_bool(c)) {
                                return it;
                              } else {
                                return iff;
                              }
                            })]);
              })]);
}

function kl_or(l) {
  return /* Lambda */Block.__(7, [(function (r) {
                if (assert_bool(l)) {
                  return /* Boolean */Block.__(2, [true]);
                } else {
                  return r;
                }
              })]);
}

function kl_and(l) {
  return /* Lambda */Block.__(7, [(function (r) {
                if (assert_bool(l)) {
                  return r;
                } else {
                  return /* Boolean */Block.__(2, [false]);
                }
              })]);
}

function kl_simple_error(v) {
  if (v.tag === 1) {
    throw [
          Exn,
          v[0]
        ];
  } else {
    throw [
          Exn,
          "simple-error: first arg must be a string"
        ];
  }
}

function kl_error_to_string(v) {
  if (v.tag === 4) {
    var match = v[0];
    if (match[0] === Exn) {
      return match[1];
    } else {
      throw [
            Exn,
            "error-to-string: first arg must be an error"
          ];
    }
  } else {
    throw [
          Exn,
          "error-to-string: first arg must be an error"
        ];
  }
}

function kl_intern(v) {
  if (v.tag === 1) {
    var s = v[0];
    switch (s) {
      case "false" : 
          return /* Boolean */Block.__(2, [false]);
      case "true" : 
          return /* Boolean */Block.__(2, [true]);
      default:
        return /* Symbol */Block.__(0, [s]);
    }
  } else {
    throw [
          Exn,
          "intern: argument must be a string"
        ];
  }
}

function kl_set(n) {
  return /* Lambda */Block.__(7, [(function (v) {
                if (n.tag) {
                  throw [
                        Exn,
                        "set: first arg must be a symbol"
                      ];
                } else {
                  Hashtbl.add(globals, n[0], v);
                  return v;
                }
              })]);
}

function kl_value(n) {
  if (n.tag) {
    throw [
          Exn,
          "value: first arg must be a symbol"
        ];
  } else {
    return Hashtbl.find(globals, n[0]);
  }
}

function kl_is_number(v) {
  if (v.tag === 3) {
    return /* Boolean */Block.__(2, [true]);
  } else {
    return /* Boolean */Block.__(2, [false]);
  }
}

function kl_arith(f, a) {
  return /* Lambda */Block.__(7, [(function (b) {
                if (a.tag === 3) {
                  if (b.tag === 3) {
                    return /* Number */Block.__(3, [Curry._2(f, a[0], b[0])]);
                  } else {
                    throw [
                          Exn,
                          "+-/*: both arguments must be numbers"
                        ];
                  }
                } else {
                  throw [
                        Exn,
                        "+-/*: both arguments must be numbers"
                      ];
                }
              })]);
}

function kl_add(param) {
  return kl_arith((function (a, b) {
                return a + b;
              }), param);
}

function kl_min(param) {
  return kl_arith((function (a, b) {
                return a - b;
              }), param);
}

function kl_mul(param) {
  return kl_arith((function (a, b) {
                return a * b;
              }), param);
}

function kl_div(param) {
  return kl_arith((function (a, b) {
                return a / b;
              }), param);
}

function kl_cmp(f, a) {
  return /* Lambda */Block.__(7, [(function (b) {
                if (a.tag === 3) {
                  if (b.tag === 3) {
                    return /* Boolean */Block.__(2, [Curry._2(f, a[0], b[0])]);
                  } else {
                    throw [
                          Exn,
                          ">=<=: both arguments must be numbers"
                        ];
                  }
                } else {
                  throw [
                        Exn,
                        ">=<=: both arguments must be numbers"
                      ];
                }
              })]);
}

function kl_gt(param) {
  return kl_cmp((function (a, b) {
                return a > b;
              }), param);
}

function kl_lt(param) {
  return kl_cmp((function (a, b) {
                return a < b;
              }), param);
}

function kl_lte(param) {
  return kl_cmp((function (a, b) {
                return a <= b;
              }), param);
}

function kl_gte(param) {
  return kl_cmp((function (a, b) {
                return a >= b;
              }), param);
}

var Shen$prime1 = /* module */[
  /* Exn */Exn,
  /* functions */functions,
  /* globals */globals,
  /* assert_function */assert_function,
  /* check_symbol */check_symbol,
  /* assert_bool */assert_bool,
  /* kl_if */kl_if,
  /* kl_or */kl_or,
  /* kl_and */kl_and,
  /* kl_simple_error */kl_simple_error,
  /* kl_error_to_string */kl_error_to_string,
  /* kl_intern */kl_intern,
  /* kl_set */kl_set,
  /* kl_value */kl_value,
  /* kl_is_number */kl_is_number,
  /* kl_arith */kl_arith,
  /* kl_add */kl_add,
  /* kl_min */kl_min,
  /* kl_mul */kl_mul,
  /* kl_div */kl_div,
  /* kl_cmp */kl_cmp,
  /* kl_gt */kl_gt,
  /* kl_lt */kl_lt,
  /* kl_lte */kl_lte,
  /* kl_gte */kl_gte
];

Hashtbl.add(functions, "add", /* Lambda */Block.__(7, [(function (a) {
            return /* Lambda */Block.__(7, [(function (a$1) {
                          return Curry._1(assert_function(Curry._1(assert_function(check_symbol("+")), a)), a$1);
                        })]);
          })]));

exports.Shen$prime1 = Shen$prime1;
/* functions Not a pure module */
